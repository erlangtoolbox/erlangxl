-module(xl_json_bindc).

-compile({parse_transform, do}).

-export([compile/2]).

compile(Path, Dest) ->
    Module = filename:basename(Path, filename:extension(Path)),
    HrlPath = filename:join([Dest, "include", Module ++ ".hrl"]),
    ModulePath = filename:join([Dest, "src", Module ++ ".erl"]),
    do([error_m ||
        io:format("compile ~p to ~p~n", [Path, Dest]),
        Records <- file:consult(Path),
        generate_file(HrlPath, fun(F) -> generate_records(Records, F) end),
        generate_file(ModulePath, fun(F) -> generate_module(Records, Module, F) end)
    ]).


generate_records(Records, Out) ->
    xl_lists:eforeach(fun({Name, Fields}) ->
        do([error_m ||
            Generated <- xl_lists:emap(fun(Field) -> generate_field(Field) end, Fields),
            io:format(Out, "~n-record(~s, {~n\t~s~n}).", [Name, xl_string:join(Generated, ",\n\t")])
        ])
    end, Records).

generate_field({Name, any, required}) ->
    {ok, xl_string:format("~s = error({required, ~p}) :: any()", [Name, Name])};
generate_field({Name, string, required}) ->
    {ok, xl_string:format("~s = error({required, ~p}) :: binary()", [Name, Name])};
generate_field({Name, Type, required}) when
    Type == integer; Type == float; Type == boolean; Type == atom ->
    {ok, xl_string:format("~s = error({required, ~p}) :: ~s()", [Name, Name, Type])};
generate_field({Name, {list, string}, required}) ->
    {ok, xl_string:format("~s = error({required, ~p}) :: [binary()]", [Name, Name])};
generate_field({Name, {list, Type}, required}) when
    Type == integer; Type == float; Type == boolean; Type == atom ->
    {ok, xl_string:format("~s = error({required, ~p}) :: [~s()]", [Name, Name, Type])};
generate_field({Name, {list, Type}, required}) when is_atom(Type) ->
    {ok, xl_string:format("~s = error({required, ~p}) :: [#~s{}]", [Name, Name, Type])};
generate_field({Name, {list, {_Mod, Type}}, required}) when is_atom(Type) ->
    {ok, xl_string:format("%:: #[~s{}]~n\t~s = error({required, ~p})", [Type, Name, Name])};
generate_field({Name, {_Mod, Type}, required}) when is_atom(Type) ->
    {ok, xl_string:format("%:: #~s{}~n\t~s = error({required, ~p})", [Type, Name, Name])};
generate_field({Name, Type, required}) when is_atom(Type) ->
    {ok, xl_string:format("~s = error({required, ~p}) :: #~s{}", [Name, Name, Type])};
generate_field({Name, any, optional}) ->
    {ok, xl_string:format("~s :: any()", [Name])};
generate_field({Name, any, {optional, Default}}) ->
    {ok, xl_string:format("~s = ~p :: any()", [Name, Default])};
generate_field({Name, string, {optional, Default}}) ->
    {ok, xl_string:format("~s = ~p :: binary()", [Name, Default])};
generate_field({Name, Type, {optional, Default}}) when
    Type == integer; Type == float; Type == boolean; Type == atom ->
    {ok, xl_string:format("~s = ~p :: ~s()", [Name, Default, Type])};
generate_field({Name, {list, string}, {optional, Default}}) ->
    {ok, xl_string:format("~s = ~p :: [binary()]", [Name, Default])};
generate_field({Name, {list, Type}, {optional, Default}}) when
    Type == integer; Type == float; Type == boolean; Type == atom ->
    {ok, xl_string:format("~s = ~p :: [~s()]", [Name, Default, Type])};
generate_field({Name, {list, Type}, {optional, Default}}) when is_atom(Type) ->
    {ok, xl_string:format("~s = ~p :: [#~s{}]", [Name, Default, Type])};
generate_field({Name, {list, {_Mod, Type}}, {optional, Default}}) when is_atom(Type) ->
    {ok, xl_string:format("% :: [#~s{}]\n\t~s = ~p", [Type, Name, Default])};
generate_field({Name, {_Mod, Type}, optional}) when is_atom(Type) ->
    {ok, xl_string:format("%:: #~s{}~n\t~s", [Type, Name])};
generate_field({Name, Type, optional}) when is_atom(Type) ->
    {ok, xl_string:format("~s :: #~s{}", [Name, Type])};
generate_field(D) -> {error, {dont_understand, D}}.

generate_file(Path, Generate) ->
    erlang:display("...generating " ++ Path),
    do([error_m ||
        filelib:ensure_dir(Path),
        Out <- file:open(Path, [write]),
        file:write(Out, "%% Generated by " ++ atom_to_list(?MODULE) ++ "\n"),
        try
            Generate(Out)
        after
            file:close(Out)
        end
    ]).

generate_module(Records, Name, Out) ->
    do([error_m ||
        file:write(Out, "-module(" ++ Name ++ ").\n\n"),
        file:write(Out, "-include(\"" ++ Name ++ ".hrl\").\n\n"),
        file:write(Out, "-export([to_json/1, from_json/2, from_json_/2]).\n\n"),
        file:write(Out, "to_json(undefined) -> \"null\";\n\n"),
        generate_to_json(Records, Out),
        file:write(Out, "from_json(Json, Record) when is_list(Json); is_binary(Json) ->\n"
        "\tcase ktj_parse:parse(Json) of\n"
        "\t\t{J, _, _} ->\n"
        "\t\t\ttry\n"
        "\t\t\t\t{ok, from_json_(J, Record)}\n"
        "\t\t\tcatch\n"
        "\t\t\t\terror:X -> {error, X}\n"
        "\t\t\tend;\n"
        "\t\tX -> X\n"
        "end.\n\n"),
        file:write(Out, "from_json_(undefined, _Record)  -> undefined;\n\n"),
        generate_from_json(Records, Out)
    ]).

generate_to_json(Records, Out) ->
    do([error_m ||
        Functions <- xl_lists:emap(fun({RecordName, Fields}) ->
            do([error_m ||
                Generated <- xl_lists:emap(fun(Field) -> generate_to_json_field(RecordName, Field) end, Fields),
                return(
                    xl_string:format(
                        "to_json(R=#~p{}) ->\n\txl_string:join([\"{\",\n~s\n\t\"}\"])", [RecordName,
                            xl_string:join([xl_string:format("\t\t~s,", [F]) || F <- Generated], " \",\",\n")
                        ]
                    )
                )
            ])
        end, Records),
        file:write(Out, xl_string:join(Functions, ";\n") ++ ".\n\n")
    ]).

generate_to_json_field(RecordName, {Name, string, _}) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", xl_json:to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, atom, _}) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", xl_json:to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, integer, _}) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", xl_json:to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, float, _}) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", xl_json:to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, boolean, _}) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", xl_json:to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, any, _}) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", xl_json:to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, {list, string}, _}) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", xl_json:to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, {list, atom}, _}) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", xl_json:to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, {list, integer}, _}) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", xl_json:to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, {list, float}, _}) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", xl_json:to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, {list, boolean}, _}) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", xl_json:to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, {list, {Mod, Rec}}, _}) when is_atom(Rec) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", \"[\" ++ string:join([~p:to_json(X)||X <- R#~p.~p], \",\") ++ \"]\"", [Name, Mod, RecordName, Name])};
generate_to_json_field(RecordName, {Name, {list, Rec}, _}) when is_atom(Rec) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", \"[\" ++ string:join([to_json(X)||X <- R#~p.~p], \",\") ++ \"]\"", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, {Mod, Rec}, _}) when is_atom(Rec) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", ~p:to_json(R#~p.~p)", [Name, Mod, RecordName, Name])};
generate_to_json_field(RecordName, {Name, Rec, _}) when is_atom(Rec) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, Field) ->
    {error, {dont_understand, {RecordName, Field}}}.

generate_from_json(Records, Out) ->
    do([error_m ||
        Functions <- xl_lists:emap(fun({RecordName, Fields}) ->
            do([error_m ||
                Generated <- xl_lists:emap(fun(Field) -> generate_from_json_field(Field) end, Fields),
                return(
                    xl_string:format(
                        "from_json_(J, ~p) ->\n\t#~p{\n~s\n\t}",
                        [RecordName, RecordName, xl_string:join([xl_string:format("\t\t~s", [F]) || F <- Generated], ",\n")]
                    )
                )
            ])
        end, Records),
        file:write(Out, xl_string:join(Functions, ";\n") ++ ".\n\n")
    ]).

generate_from_json_field({Name, Type, {optional, Default}}) when
    Type == string; Type == atom; Type == integer; Type == float; Type == boolean;
    Type == {list, string}; Type == {list, integer}; Type == {list, float};
    Type == {list, boolean}; Type == {list, atom} ->
    {ok, xl_string:format("~p = xl_json:ktuo_find(~p, J, ~p, ~p)", [Name, Name, Default, Type])};
generate_from_json_field({Name, Type, required}) when
    Type == string; Type == atom; Type == integer; Type == float; Type == boolean;
    Type == {list, string}; Type == {list, integer}; Type == {list, float};
    Type == {list, boolean}; Type == {list, atom} ->
    {ok, xl_string:format("~p = xl_json:ktuo_find(~p, J, ~p)", [Name, Name, Type])};
generate_from_json_field({Name, {list, {Mod, Rec}}, {optional, Default}}) when is_atom(Rec) ->
    {ok, xl_string:format("~p = [~p:from_json_(O, ~p) || O <- xl_json:ktuo_find(~p, J, ~p, undefined)]", [Name, Mod, Rec, Name, Default])};
generate_from_json_field({Name, {list, Rec}, {optional, Default}}) when is_atom(Rec) ->
    {ok, xl_string:format("~p = [from_json_(O, ~p) || O <- xl_json:ktuo_find(~p, J, ~p, undefined)]", [Name, Rec, Name, Default])};
generate_from_json_field({Name, {list, {Mod, Rec}}, required}) when is_atom(Rec) ->
    {ok, xl_string:format("~p = [~p:from_json_(O, ~p) || O <- xl_json:ktuo_find(~p, J, undefined)]", [Name, Mod, Rec, Name])};
generate_from_json_field({Name, {list, Rec}, required}) when is_atom(Rec) ->
    {ok, xl_string:format("~p = [from_json_(O, ~p) || O <- xl_json:ktuo_find(~p, J, undefined)]", [Name, Rec, Name])};
generate_from_json_field({Name, {Mod, Rec}, _}) when is_atom(Rec) ->
    {ok, xl_string:format("~p = ~p:from_json_(xl_json:ktuo_find(~p, J, undefined), ~p)", [Name, Mod, Name, Rec])};
generate_from_json_field({Name, Rec, _}) when is_atom(Rec) ->
    {ok, xl_string:format("~p = from_json_(xl_json:ktuo_find(~p, J, undefined), ~p)", [Name, Name, Rec])};
generate_from_json_field(Field) -> {error, {dont_understand, Field}}.
