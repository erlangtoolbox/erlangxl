-module(xl_json_bindc).

-compile({parse_transform, do}).

-export([compile/2, cast/3, check_required/1]).

%runtime
-export([cast/4]).

-define(JSON_API, xl_json_jiffy).

compile(Path, Dest) ->
    Module = filename:basename(Path, filename:extension(Path)),
    HrlPath = filename:join([Dest, "include", Module ++ ".hrl"]),
    ModulePath = filename:join([Dest, "src", Module ++ ".erl"]),
    do([error_m ||
        io:format("compile ~p to ~p~n", [Path, Dest]),
        Records <- file:consult(Path),
        generate_file(HrlPath, fun(F) -> generate_records(Records, F) end),
        generate_file(ModulePath, fun(F) -> generate_module(Records, Module, F) end)
    ]).


generate_records(Records, Out) ->
    xl_lists:eforeach(fun({Name, Fields}) ->
        do([error_m ||
            Generated <- xl_lists:emap(fun(Field) -> generate_field(Field) end, Fields),
            io:format(Out, "~n-record(~s, {~n\t~s~n}).", [Name, xl_string:join(Generated, ",\n\t")])
        ])
    end, Records).

-define(is_primitive_type(Type), Type == integer; Type == float; Type == boolean; Type == atom; Type == binary; Type == string; Type == any).
-define(is_primitive_type(Type, Default),
    is_binary(Default), Type == string;
    Default == undefined, Type == string;
    is_binary(Default), Type == binary;
    Default == undefined, Type == binary;
    is_integer(Default), Type == integer;
    Default == undefined, Type == integer;
    is_float(Default), Type == float;
    Default == undefined, Type == float;
    is_atom(Default), Type == atom;
    Default == true, Type == boolean;
    Default == false, Type == boolean;
    is_list(Default), Type == any;
    Default == undefined, Type == any
).

%lists
generate_field({Name, {list, Type}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("~p = error({required, ~p}) :: [~p()]", [Name, Name, Type])};
generate_field({Name, {list, Type}}) when is_atom(Type) ->
    {ok, xl_string:format("~p = error({required, ~p}) :: [#~p{}]", [Name, Name, Type])};
generate_field({Name, {list, {Module, Type}}}) when is_atom(Module), is_atom(Type) ->
    {ok, xl_string:format("~p = error({required, ~p})", [Name, Name])};

%lists with defaults
generate_field({Name, {list, Type, Default}}) when is_list(Default), ?is_primitive_type(Type) ->
    {ok, xl_string:format("~p = ~p :: [~p()]", [Name, Default, Type])};
generate_field({Name, {list, Type, Default}}) when is_atom(Type), is_list(Default) ->
    {ok, xl_string:format("~p = ~p :: [#~p{}]", [Name, Default, Type])};
generate_field({Name, {list, {Module, Type}, Default}}) when is_atom(Module), is_atom(Type), is_list(Default) ->
    {ok, xl_string:format("~p = ~p", [Name, Default])};

%options
generate_field({Name, {option, Type}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("~p :: option_m:monad(~p())", [Name, Type])};
generate_field({Name, {option, Type}}) when is_atom(Type) ->
    {ok, xl_string:format("~p :: option_m:monad(#~p{})", [Name, Type])};
generate_field({Name, {option, {Module, Type}}}) when is_atom(Module), is_atom(Type) ->
    {ok, xl_string:format("~p", [Name])};

%options with defaults
generate_field({Name, {option, Type, Default}}) when ?is_primitive_type(Type, Default) ->
    {ok, xl_string:format("~p = {ok, ~p} :: option_m:monad(~p())", [Name, Default, Type])};

%enums
generate_field({Name, {enum, Type, _Enum}}) -> generate_field({Name, Type});

%either
generate_field({Name, {either, _Types}}) ->
    {ok, xl_string:format("~p = error({required, ~p})", [Name, Name])};

%primitives with defaults
generate_field({Name, {Type, Default}}) when ?is_primitive_type(Type, Default) ->
    {ok, xl_string:format("~p = ~p :: ~p()", [Name, Default, Type])};
generate_field({Name, {string, Default}}) -> generate_field({Name, {binary, Default}});

%primitives
%% generate_field({Name, string}) -> generate_field({Name, binary});
generate_field({Name, Type}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("~p = error({required, ~p}) :: ~p()", [Name, Name, Type])};
generate_field({Name, Type}) when is_atom(Type) ->
    {ok, xl_string:format("~p = error({required, ~p}) :: #~p{}", [Name, Name, Type])};
generate_field({Name, {Type, undefined}}) when is_atom(Type) ->
    {ok, xl_string:format("~p :: #~p{}", [Name, Type])};
generate_field({Name, {Module, Type}}) when is_atom(Module), is_atom(Type) ->
    {ok, xl_string:format("~p = error({required, ~p}) ", [Name, Name])};
generate_field({Name, {{Module, Type}, undefined}}) when is_atom(Module), is_atom(Type) ->
    {ok, xl_string:format("~p", [Name])};

%wtf
generate_field(D) -> {error, {record, dont_understand, D}}.

generate_file(Path, Generate) ->
    io:format("Generate ~s~n", [Path]),
    do([error_m ||
        filelib:ensure_dir(Path),
        Out <- file:open(Path, [write]),
        file:write(Out, "%% Generated by " ++ atom_to_list(?MODULE) ++ "\n"),
        try
            Generate(Out)
        after
            file:close(Out)
        end
    ]).

generate_module(Records, Name, Out) ->
    do([error_m ||
        file:write(Out, "-module(" ++ Name ++ ").\n\n"),
        file:write(Out, "-include(\"" ++ Name ++ ".hrl\").\n\n"),
        io:format(Out, "-define(JSON_API, ~s).\n\n", [?JSON_API]),
        file:write(Out, "-export([to_json/1, from_json/2, from_json_/2, from_proplist/2, from_proplist_/2]).\n\n"),
        file:write(Out, "to_json(undefined) -> \"null\";\n\n"),
        file:write(Out, "to_json({ok, X}) -> to_json(X);\n\n"),
        file:write(Out, "to_json(L) when is_list(L) -> \"[\" ++ string:join([to_json(R) || R <- L], \",\") ++ \"]\";\n\n"),
        generate_to_json(Records, Out),
        file:write(Out, "from_json(Json, Type) ->\n"
        "\tcase ?JSON_API:from_json(Json) of\n"
        "\t\t{ok, List} when is_list(List)->\n"
        "\t\t\ttry\n"
        "\t\t\t\t{ok, [from_json_(R, Type) || R <- List]}\n"
        "\t\t\tcatch\n"
        "\t\t\t\terror:X -> {error, X}\n"
        "\t\t\tend;\n"
        "\t\t{ok, Document} ->\n"
        "\t\t\ttry\n"
        "\t\t\t\t{ok, from_json_(Document, Type)}\n"
        "\t\t\tcatch\n"
        "\t\t\t\terror:X -> {error, X}\n"
        "\t\t\tend;\n"
        "\t\tError -> Error\n"
        "end.\n\n"),
        file:write(Out, "from_json_(undefined, _Type)  -> undefined;\n\n"),
        generate_from_json(Records, Out),
        file:write(Out, "from_proplist(Proplist, Type) -> {ok, from_proplist_(Proplist, Type)}.\n\n"),
        file:write(Out, "from_proplist_(undefined, _Type)  -> undefined;\n\n"),
        generate_from_proplist(Records, Out)
    ]).

generate_to_json(Records, Out) ->
    do([error_m ||
        Functions <- xl_lists:emap(fun({RecordName, Fields}) ->
            do([error_m ||
                Generated <- xl_lists:emap(fun(Field) -> generate_to_json_field(RecordName, Field) end, Fields),
                return(
                    xl_string:format(
                        "to_json(R=#~p{}) ->\n\txl_string:join([\"{\",\n~s\n\t\"}\"])", [RecordName,
                            xl_string:join([xl_string:format("\t\t~s,", [F]) || F <- Generated], " \",\",\n")
                        ]
                    )
                )
            ])
        end, Records),
        file:write(Out, xl_string:join(Functions, ";\n") ++ ".\n\n")
    ]).

generate_to_json_field(RecordName, {Name, {enum, Type, _Enumeration}}) -> generate_to_json_field(RecordName, {Name, Type});
generate_to_json_field(RecordName, {Name, {either, _Types}}) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", xl_json:to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, Type}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", xl_json:to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, {Type, _Default}}) when ?is_primitive_type(Type) ->
    generate_to_json_field(RecordName, {Name, Type});
generate_to_json_field(RecordName, {Name, {list, Type}}) when ?is_primitive_type(Type) ->
    generate_to_json_field(RecordName, {Name, Type});
generate_to_json_field(RecordName, {Name, {list, Type, _Default}}) when ?is_primitive_type(Type) ->
    generate_to_json_field(RecordName, {Name, Type});
generate_to_json_field(RecordName, {Name, {option, Type}}) when ?is_primitive_type(Type) ->
    generate_to_json_field(RecordName, {Name, Type});
generate_to_json_field(RecordName, {Name, {option, Type, _Default}}) when ?is_primitive_type(Type) ->
    generate_to_json_field(RecordName, {Name, Type});
generate_to_json_field(RecordName, {Name, {option, Type}}) when is_atom(Type) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, {option, {Module, Type}}}) when is_atom(Module), is_atom(Type) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", ~p:to_json(R#~p.~p)", [Name, Module, RecordName, Name])};
generate_to_json_field(RecordName, {Name, {list, Type}}) when is_atom(Type) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", \"[\" ++ string:join([to_json(X)||X <- R#~p.~p], \",\") ++ \"]\"", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, {list, Type, _Default}}) when is_atom(Type) ->
    generate_to_json_field(RecordName, {Name, {list, Type}});
generate_to_json_field(RecordName, {Name, {list, {Module, Type}}}) when is_atom(Module), is_atom(Type) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", \"[\" ++ string:join([~p:to_json(X)||X <- R#~p.~p], \",\") ++ \"]\"", [Name, Module, RecordName, Name])};
generate_to_json_field(RecordName, {Name, {list, {Module, Type}, _Default}}) when is_atom(Module), is_atom(Type) ->
    generate_to_json_field(RecordName, {Name, {list, {Module, Type}}});
generate_to_json_field(RecordName, {Name, Type}) when is_atom(Type) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", to_json(R#~p.~p)", [Name, RecordName, Name])};
generate_to_json_field(RecordName, {Name, {Type, undefined}}) when is_atom(Type) ->
    generate_to_json_field(RecordName, {Name, Type});
generate_to_json_field(RecordName, {Name, {Module, Type}}) when is_atom(Module), is_atom(Type) ->
    {ok, xl_string:format("\"\\\"~p\\\":\", ~p:to_json(R#~p.~p)", [Name, Module, RecordName, Name])};
generate_to_json_field(RecordName, {Name, {{Module, Type}, undefined}}) when is_atom(Module), is_atom(Type) ->
    generate_to_json_field(RecordName, {Name, {Module, Type}});
generate_to_json_field(_RecordName, Field) -> {error, {to_json, dont_understand, Field}}.

generate_from_json(Records, Out) ->
    do([error_m ||
        Functions <- xl_lists:emap(fun({RecordName, Fields}) ->
            do([error_m ||
                Generated <- xl_lists:emap(fun(Field) -> generate_from_json_field(RecordName, Field) end, Fields),
                return(
                    xl_string:format("from_json_(J, ~p) ->\n\tR = ?JSON_API:bind(fun\n\t\t~s\n\tend, ~p, J),\n\txl_json_bindc:check_required(R),\n\tR", [
                        RecordName,
                        xl_string:join([xl_string:format("\t\t~s", [F]) || F <- Generated], ";\n"),
                        list_to_tuple([RecordName | lists:map(fun default_or_required/1, Fields)])
                    ])
                )
            ])
        end, Records),
        file:write(Out, xl_string:join(Functions, ";\n") ++ ".\n\n")
    ]).

default_or_required({Name, {enum, Type, _Enumeration}}) when ?is_primitive_type(Type) -> {required, Name};
default_or_required({Name, {either, _Types}}) -> {required, Name};
default_or_required({_Name, {enum, {Type, Default}, _Enumeration}}) when ?is_primitive_type(Type) -> Default;
default_or_required({Name, Type}) when ?is_primitive_type(Type) -> {required, Name};
default_or_required({Name, {enum, {list, Type}, _Enumeration}}) when ?is_primitive_type(Type) -> {required, Name};
default_or_required({Name, {list, Type}}) when ?is_primitive_type(Type) -> {required, Name};
default_or_required({_Name, {option, Type}}) when ?is_primitive_type(Type) -> undefined;
default_or_required({_Name, {option, Type, Default}}) when ?is_primitive_type(Type) -> {ok, Default};
default_or_required({_Name, {Type, Default}}) when ?is_primitive_type(Type) -> Default;
default_or_required({_Name, {list, Type, Default}}) when ?is_primitive_type(Type) -> Default;
default_or_required({_Name, {enum, {list, Type, Default}, _Enumeration}}) when ?is_primitive_type(Type) -> Default;
default_or_required({_Name, {list, {Module, Type}, Default}}) when is_atom(Module), is_atom(Type) -> Default;
default_or_required({_Name, {list, Type, Default}}) when is_atom(Type) -> Default;
default_or_required({Name, {list, {Module, Type}}}) when is_atom(Module), is_atom(Type) -> {required, Name};
default_or_required({Name, {list, Type}}) when is_atom(Type) -> {required, Name};
default_or_required({_Name, {option, {Module, Type}}}) when is_atom(Module), is_atom(Type) -> undefined;
default_or_required({_Name, {option, Type}}) when is_atom(Type) -> undefined;
default_or_required({_Name, {Type, undefined}}) when is_atom(Type) -> undefined;
default_or_required({Name, Type}) when is_atom(Type) -> {required, Name};
default_or_required({_Name, {{Module, Type}, undefined}}) when is_atom(Module), is_atom(Type) -> undefined;
default_or_required({Name, {Module, Type}}) when is_atom(Module), is_atom(Type) -> {required, Name};
default_or_required(Field) -> {error, {default_or_required, dont_understand, Field}}.

generate_from_json_field(RecordName, {Name, Qualified = {enum, Type, _Enumeration}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, ~p)}", [?JSON_API:field_name_presentation(Name), RecordName, Name, Qualified])};
generate_from_json_field(RecordName, {Name, Qualified = {either, _Types}}) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, ~p)}", [?JSON_API:field_name_presentation(Name), RecordName, Name, Qualified])};
generate_from_json_field(RecordName, {Name, {enum, {Type, _Default}, Enumeration}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, ~p)}", [?JSON_API:field_name_presentation(Name), RecordName, Name, {enum, Type, Enumeration}])};
generate_from_json_field(RecordName, {Name, Type}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, ~p)}", [?JSON_API:field_name_presentation(Name), RecordName, Name, Type])};
generate_from_json_field(RecordName, {Name, Qualified = {enum, {list, Type}, _Enumeration}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, ~p)}", [?JSON_API:field_name_presentation(Name), RecordName, Name, Qualified])};
generate_from_json_field(RecordName, {Name, Qualified = {list, Type}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, ~p)}", [?JSON_API:field_name_presentation(Name), RecordName, Name, Qualified])};
generate_from_json_field(RecordName, {Name, Qualified = {option, Type}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, ~p)}", [?JSON_API:field_name_presentation(Name), RecordName, Name, Qualified])};
generate_from_json_field(RecordName, {Name, {option, Type, _Default}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, ~p)}", [?JSON_API:field_name_presentation(Name), RecordName, Name, {option, Type}])};
generate_from_json_field(RecordName, {Name, {Type, _Default}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, ~p)}", [?JSON_API:field_name_presentation(Name), RecordName, Name, Type])};
generate_from_json_field(RecordName, {Name, {list, Type, _Default}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, ~p)}", [?JSON_API:field_name_presentation(Name), RecordName, Name, {list, Type}])};
generate_from_json_field(RecordName, {Name, {enum, {list, Type, _Default}, Enumeration}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, ~p)}", [?JSON_API:field_name_presentation(Name), RecordName, Name, {enum, {list, Type}, Enumeration}])};
generate_from_json_field(RecordName, {Name, {list, {Module, Type}, _Default}}) when is_atom(Module), is_atom(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, ~p)}", [?JSON_API:field_name_presentation(Name), RecordName, Name, {list, {Module, Type}}])};
generate_from_json_field(RecordName, {Name, {list, Type, _Default}}) when is_atom(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, {list, {?MODULE, ~p}})}", [?JSON_API:field_name_presentation(Name), RecordName, Name, Type])};
generate_from_json_field(RecordName, {Name, {list, {Module, Type}}}) when is_atom(Module), is_atom(Type) ->
    generate_from_json_field(RecordName, {Name, {list, {Module, Type}, {required, Name}}});
generate_from_json_field(RecordName, {Name, {list, Type}}) when is_atom(Type) ->
    generate_from_json_field(RecordName, {Name, {list, Type, {required, Name}}});
generate_from_json_field(RecordName, {Name, Qualified = {option, {Module, Type}}}) when is_atom(Module), is_atom(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, ~p)}", [?JSON_API:field_name_presentation(Name), RecordName, Name, Qualified])};
generate_from_json_field(RecordName, {Name, {option, Type}}) when is_atom(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, {option, {?MODULE, ~p}})}", [?JSON_API:field_name_presentation(Name), RecordName, Name, Type])};
generate_from_json_field(RecordName, {Name, {Type, undefined}}) when is_atom(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, {?MODULE, ~p})}", [?JSON_API:field_name_presentation(Name), RecordName, Name, Type])};
generate_from_json_field(RecordName, {Name, Type}) when is_atom(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, {?MODULE, ~p})}", [?JSON_API:field_name_presentation(Name), RecordName, Name, Type])};
generate_from_json_field(RecordName, {Name, {Qualified = {Module, Type}, undefined}}) when is_atom(Module), is_atom(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, ~p)}", [?JSON_API:field_name_presentation(Name), RecordName, Name, Qualified])};
generate_from_json_field(RecordName, {Name, Qualified = {Module, Type}}) when is_atom(Module), is_atom(Type) ->
    {ok, xl_string:format("(~p, Value, T) -> T#~p{~p = xl_json_bindc:cast({json, ?JSON_API}, Value, ~p)}", [?JSON_API:field_name_presentation(Name), RecordName, Name, Qualified])};
generate_from_json_field(RecordName, Field) -> {error, {from_json, dont_understand, RecordName, Field}}.

% runtime functions

check_required(Tuple) -> lists:foreach(fun(R = {required, _}) -> error(R); (_) -> ok end, tuple_to_list(Tuple)).

check_enumeration(Value, {seq, F, T}) -> check_enumeration(Value, lists:seq(F, T));
check_enumeration(Value, Enumeration) when is_list(Enumeration) ->
    case lists:member(Value, Enumeration) of
        true -> Value;
        false -> error({illegal_enum_value, Value})
    end.

check_array_content(string, List) -> check_array_content(binary, List);
check_array_content(binary, List) ->
    case lists:all(fun is_binary/1, List) of
        true -> List;
        false -> error({illegal_array_value, List})
    end;
check_array_content(_, Value) -> Value.

is_type(V, integer) when is_integer(V) -> true;
is_type(V, float) when is_float(V) -> true;
is_type(V, atom) when is_binary(V) -> true;
is_type(_V, _Type) -> false.

-spec(cast(module(), any(), term()) -> any()).
cast(_Source, null, _Type) -> undefined;

cast(Source, V, EitherType = {either, Types}) ->
    case xl_lists:find(fun(Type) -> is_type(V, Type) end, Types) of
        {ok, Type} -> cast(Source, V, Type);
        undefined -> error({cannot_cast, V, EitherType})
    end;

cast(_Source, V, {enum, atom, Enumeration}) -> check_enumeration(xl_convert:to(atom, V), Enumeration);
cast(_Source, V, {enum, {list, atom}, Enumeration}) when is_list(V) ->
    [check_enumeration(xl_convert:to(atom, X), Enumeration) || X <- V];
cast(_Source, V, atom) -> xl_convert:to(atom, V);
cast(_Source, V, {list, atom}) -> lists:map(fun(X) -> xl_convert:to(atom, X) end, V);
cast(_Source, V, {option, atom}) -> {ok, xl_convert:to(atom, V)};

cast(_Source, V, {enum, string, Enumeration}) -> check_enumeration(V, Enumeration);
cast(_Source, V, {enum, {list, string}, Enumeration}) when is_list(V) ->
    [check_enumeration(X, Enumeration) || X <- V];
cast(_Source, V, string) when is_binary(V) -> V;
cast(_Source, V, string) when is_integer(V) -> xl_convert:to(binary, V);
cast(_Source, V, {list, string}) when is_list(V) -> check_array_content(string, V);
cast(_Source, V, {option, string}) when is_binary(V) -> {ok, V};
cast(_Source, V, {option, string}) when is_integer(V) -> {ok, xl_convert:to(binary, V)};

cast(_Source, V, {enum, binary, Enumeration}) -> check_enumeration(V, Enumeration);
cast(_Source, V, {enum, {list, binary}, Enumeration}) when is_list(V) ->
    lists:map(fun(X) -> check_enumeration(X, Enumeration) end, V);
cast(_Source, V, binary) when is_binary(V) -> V;
cast(_Source, V, {list, binary}) when is_list(V) -> check_array_content(binary, V);
cast(_Source, V, {option, binary}) when is_binary(V) -> {ok, V};

cast(_Source, V, {enum, integer, Enumeration}) -> check_enumeration(V, Enumeration);
cast(_Source, V, {enum, {list, integer}, Enumeration}) when is_list(V) ->
    [check_enumeration(X, Enumeration) || X <- V];
cast(_Source, V, integer) when is_integer(V) -> V;
cast(_Source, V, integer) when is_binary(V) -> xl_convert:to(integer, V);
cast(_Source, V, {list, integer}) when is_list(V) -> V;
cast(_Source, V, {option, integer}) when is_integer(V) -> {ok, V};

cast(_Source, V, {enum, float, Enumeration}) -> check_enumeration(xl_convert:to(float, V), Enumeration);
cast(_Source, V, {enum, {list, float}, Enumeration}) when is_list(V) ->
    [check_enumeration(xl_convert:to(float, X), Enumeration) || X <- V];
cast(_Source, V, float) when is_float(V) -> V;
cast(_Source, V, float) when is_integer(V); is_binary(V) -> xl_convert:to(float, V);
cast(_Source, V, {list, float}) when is_list(V) -> [xl_convert:to(float, X) || X <- V];
cast(_Source, V, {option, float}) when is_float(V) -> {ok, V};
cast(_Source, V, {option, float}) when is_integer(V); is_binary(V) -> {ok, xl_convert:to(float, V)};

cast(_Source, true, boolean) -> true;
cast(_Source, false, boolean) -> false;
cast(_Source, <<"true">>, boolean) -> true;
cast(_Source, <<"false">>, boolean) -> false;
cast(_Source, V, {list, boolean}) when is_list(V) -> V;
cast(_Source, V, {option, boolean}) when V == true; V == false -> {ok, V};

cast({json, JsonApi}, V, any) -> JsonApi:to_abstract(V);
cast({json, JsonApi}, V, {list, any}) when is_list(V) -> [JsonApi:to_abstract(X) || X <- V];
cast({json, JsonApi}, V, {option, any}) -> {ok, JsonApi:to_abstract(V)};

cast(proplist, V, any) -> V;
cast(proplist, V, {list, any}) when is_list(V) -> V;
cast(proplist, V, {option, any}) -> {ok, V};

cast({json, _JsonApi}, V, {list, {Module, Record}}) when is_list(V) -> [Module:from_json_(O, Record) || O <- V];
cast({json, _JsonApi}, V, {option, {Module, Record}}) -> {ok, Module:from_json_(V, Record)};
cast({json, _JsonApi}, V, {Module, Record}) -> Module:from_json_(V, Record);

%% cast(proplist, V, {list, {Module, Record}}) when is_list(V) -> [Module:from_proplist_(O, Record) || O <- V];
cast(proplist, V, {option, {Module, Record}}) -> {ok, Module:from_proplist_(V, Record)};
cast(proplist, V, {Module, Record}) -> Module:from_proplist_(V, Record);

cast(_Source, Value, Type) -> error({cannot_cast, Value, Type}).

-spec(cast(module(), option_m:monad(any()), term(), any()) -> any()).
cast(_Source, {ok, null}, _Type, _Default) -> undefined;

cast(Source, {ok, V}, EitherType = {either, Types}, Default) ->
    case xl_lists:find(fun(Type) -> is_type(V, Type) end, Types) of
        {ok, Type} -> cast(Source, {ok, V}, Type, Default);
        undefined -> error({cannot_cast, V, EitherType})
    end;

cast(_Source, {ok, V}, {enum, atom, Enumeration}, _Default) -> check_enumeration(xl_convert:to(atom, V), Enumeration);
cast(_Source, {ok, V}, {enum, {list, atom}, Enumeration}, _Default) when is_list(V) ->
    [check_enumeration(xl_convert:to(atom, X), Enumeration) || X <- V];
cast(_Source, {ok, V}, atom, _Default) -> xl_convert:to(atom, V);
cast(_Source, {ok, V}, {list, atom}, _Default) -> lists:map(fun(X) -> xl_convert:to(atom, X) end, V);
cast(_Source, {ok, V}, {option, atom}, _Default) -> {ok, xl_convert:to(atom, V)};

cast(_Source, {ok, V}, {enum, string, Enumeration}, _Default) -> check_enumeration(V, Enumeration);
cast(_Source, {ok, V}, {enum, {list, string}, Enumeration}, _Default) when is_list(V) ->
    [check_enumeration(X, Enumeration) || X <- V];
cast(_Source, {ok, V}, string, _Default) when is_binary(V) -> V;
cast(_Source, {ok, V}, string, _Default) when is_integer(V) -> xl_convert:to(binary, V);
cast(_Source, {ok, V}, {list, string}, _Default) when is_list(V) -> check_array_content(string, V);
cast(_Source, {ok, V}, {option, string}, _Default) when is_binary(V) -> {ok, V};
cast(_Source, {ok, V}, {option, string}, _Default) when is_integer(V) -> {ok, xl_convert:to(binary, V)};

cast(_Source, {ok, V}, {enum, binary, Enumeration}, _Default) -> check_enumeration(V, Enumeration);
cast(_Source, {ok, V}, {enum, {list, binary}, Enumeration}, _Default) when is_list(V) ->
    lists:map(fun(X) -> check_enumeration(X, Enumeration) end, V);
cast(_Source, {ok, V}, binary, _Default) when is_binary(V) -> V;
cast(_Source, {ok, V}, {list, binary}, _Default) when is_list(V) -> check_array_content(binary, V);
cast(_Source, {ok, V}, {option, binary}, _Default) when is_binary(V) -> {ok, V};

cast(_Source, {ok, V}, {enum, integer, Enumeration}, _Default) -> check_enumeration(V, Enumeration);
cast(_Source, {ok, V}, {enum, {list, integer}, Enumeration}, _Default) when is_list(V) ->
    [check_enumeration(X, Enumeration) || X <- V];
cast(_Source, {ok, V}, integer, _Default) when is_integer(V) -> V;
cast(_Source, {ok, V}, integer, _Default) when is_binary(V) -> xl_convert:to(integer, V);
cast(_Source, {ok, V}, {list, integer}, _Default) when is_list(V) -> V;
cast(_Source, {ok, V}, {option, integer}, _Default) when is_integer(V) -> {ok, V};

cast(_Source, {ok, V}, {enum, float, Enumeration}, _Default) -> check_enumeration(xl_convert:to(float, V), Enumeration);
cast(_Source, {ok, V}, {enum, {list, float}, Enumeration}, _Default) when is_list(V) ->
    [check_enumeration(xl_convert:to(float, X), Enumeration) || X <- V];
cast(_Source, {ok, V}, float, _Default) when is_float(V) -> V;
cast(_Source, {ok, V}, float, _Default) when is_integer(V); is_binary(V) -> xl_convert:to(float, V);
cast(_Source, {ok, V}, {list, float}, _Default) when is_list(V) -> [xl_convert:to(float, X) || X <- V];
cast(_Source, {ok, V}, {option, float}, _Default) when is_float(V) -> {ok, V};
cast(_Source, {ok, V}, {option, float}, _Default) when is_integer(V); is_binary(V) -> {ok, xl_convert:to(float, V)};

cast(_Source, {ok, true}, boolean, _Default) -> true;
cast(_Source, {ok, false}, boolean, _Default) -> false;
cast(_Source, {ok, <<"true">>}, boolean, _Default) -> true;
cast(_Source, {ok, <<"false">>}, boolean, _Default) -> false;
cast(_Source, {ok, V}, {list, boolean}, _Default) when is_list(V) -> V;
cast(_Source, {ok, V}, {option, boolean}, _Default) when V == true; V == false -> {ok, V};

cast({json, JsonApi}, {ok, V}, any, _Default) -> JsonApi:to_abstract(V);
cast({json, JsonApi}, {ok, V}, {list, any}, _Default) when is_list(V) -> [JsonApi:to_abstract(X) || X <- V];
cast({json, JsonApi}, {ok, V}, {option, any}, _Default) -> {ok, JsonApi:to_abstract(V)};

cast(proplist, {ok, V}, any, _Default) -> V;
cast(proplist, {ok, V}, {list, any}, _Default) when is_list(V) -> V;
cast(proplist, {ok, V}, {option, any}, _Default) -> {ok, V};

cast({json, _JsonApi}, {ok, V}, {list, {Module, Record}}, _Default) when is_list(V) -> [Module:from_json_(O, Record) || O <- V];
cast({json, _JsonApi}, {ok, V}, {option, {Module, Record}}, _Default) -> {ok, Module:from_json_(V, Record)};
cast({json, _JsonApi}, {ok, V}, {Module, Record}, _Default) -> Module:from_json_(V, Record);

%% cast(proplist, {ok, V}, {list, {Module, Record}}, _Default) when is_list(V) -> [Module:from_proplist_(O, Record) || O <- V];
cast(proplist, {ok, V}, {option, {Module, Record}}, _Default) -> {ok, Module:from_proplist_(V, Record)};
cast(proplist, {ok, V}, {Module, Record}, _Default) -> Module:from_proplist_(V, Record);

cast(_Source, undefined, _Type, E = {required, _}) -> error(E);

cast(_Source, undefined, {option, _}, undefined) -> undefined;
cast(_Source, undefined, {option, _}, Default) -> {ok, Default};
cast(_Source, undefined, _Type, Default) -> Default;

cast(_Source, Value, Type, _Default) -> error({cannot_cast, Value, Type}).

generate_from_proplist(Records, Out) ->
    do([error_m ||
        Functions <- xl_lists:emap(fun({RecordName, Fields}) ->
            do([error_m ||
                Generated <- xl_lists:emap(fun(Field) -> generate_from_proplist_field(Field) end, Fields),
                return(
                    xl_string:format(
                        "from_proplist_(J, ~p) ->\n\t#~p{\n~s\n\t}",
                        [RecordName, RecordName, xl_string:join([xl_string:format("\t\t~s", [F]) || F <- Generated], ",\n")]
                    )
                )
            ])
        end, Records),
        file:write(Out, xl_string:join(Functions, ";\n") ++ ".\n\n")
    ]).

generate_from_proplist_field({Name, Qualified = {enum, Type, _Enumeration}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, xl_lists:kvfind(~p, J), ~p, ~p)", [Name, Name, Qualified, {required, Name}])};
generate_from_proplist_field({Name, Qualified = {either, _Types}}) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, xl_lists:kvfind(~p, J), ~p, ~p)", [Name, Name, Qualified, {required, Name}])};
generate_from_proplist_field({Name, {enum, {Type, Default}, Enumeration}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, xl_lists:kvfind(~p, J), ~p, ~p)", [Name, Name, {enum, Type, Enumeration}, Default])};
generate_from_proplist_field({Name, Type}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, xl_lists:kvfind(~p, J), ~p, ~p)", [Name, Name, Type, {required, Name}])};
generate_from_proplist_field({Name, Qualified = {enum, {list, Type}, _Enumeration}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, xl_lists:kvfind(~p, J), ~p, ~p)", [Name, Name, Qualified, {required, Name}])};
generate_from_proplist_field({Name, Qualified = {list, Type}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, xl_lists:kvfind(~p, J), ~p, ~p)", [Name, Name, Qualified, {required, Name}])};
generate_from_proplist_field({Name, Qualified = {option, Type}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, xl_lists:kvfind(~p, J), ~p, ~p)", [Name, Name, Qualified, undefined])};
generate_from_proplist_field({Name, {option, Type, Default}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, xl_lists:kvfind(~p, J), ~p, ~p)", [Name, Name, {option, Type}, Default])};
generate_from_proplist_field({Name, {Type, Default}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, xl_lists:kvfind(~p, J), ~p, ~p)", [Name, Name, Type, Default])};
generate_from_proplist_field({Name, {list, Type, Default}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, xl_lists:kvfind(~p, J), ~p, ~p)", [Name, Name, {list, Type}, Default])};
generate_from_proplist_field({Name, {enum, {list, Type, Default}, Enumeration}}) when ?is_primitive_type(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, xl_lists:kvfind(~p, J), ~p, ~p)", [Name, Name, {enum, {list, Type}, Enumeration}, Default])};
generate_from_proplist_field({Name, {list, {Module, Type}, Default}}) when is_atom(Module), is_atom(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, xl_lists:kvfind(~p, J), ~p, ~p)", [Name, Name, {list, {Module, Type}}, Default])};
generate_from_proplist_field({Name, {list, Type, Default}}) when is_atom(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, xl_lists:kvfind(~p, J), {list, {?MODULE, ~p}}, ~p)", [Name, Name, Type, Default])};
generate_from_proplist_field({Name, {list, {Module, Type}}}) when is_atom(Module), is_atom(Type) ->
    generate_from_proplist_field({Name, {list, {Module, Type}, {required, Name}}});
generate_from_proplist_field({Name, {list, Type}}) when is_atom(Type) ->
    generate_from_proplist_field({Name, {list, Type, {required, Name}}});
generate_from_proplist_field({Name, Qualified = {option, {Module, Type}}}) when is_atom(Module), is_atom(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, {ok, J}, ~p, ~p)", [Name, Qualified, undefined])};
generate_from_proplist_field({Name, {option, Type}}) when is_atom(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, {ok, J}, {option, {?MODULE, ~p}}, ~p)", [Name, Type, undefined])};
generate_from_proplist_field({Name, {Type, undefined}}) when is_atom(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, {ok, J}, {?MODULE, ~p}, ~p)", [Name, Type, undefined])};
generate_from_proplist_field({Name, Type}) when is_atom(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, {ok, J}, {?MODULE, ~p}, ~p)", [Name, Type, {required, Name}])};
generate_from_proplist_field({Name, {Qualified = {Module, Type}, undefined}}) when is_atom(Module), is_atom(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, {ok, J}, ~p, ~p)", [Name, Qualified, undefined])};
generate_from_proplist_field({Name, Qualified = {Module, Type}}) when is_atom(Module), is_atom(Type) ->
    {ok, xl_string:format("~p = xl_json_bindc:cast(proplist, {ok, J}, ~p, ~p)", [Name, Qualified, {required, Name}])};
generate_from_proplist_field(Field) -> {error, {from_proplist, dont_understand, Field}}.
